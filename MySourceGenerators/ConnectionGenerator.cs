using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;

namespace MySourceGenerators
{
    [Generator]
    public class ConnectionGenerator : ISourceGenerator
    {
        string attributeSource = $@"// <auto-generated/>
using System;

namespace Connect
{{
    [AttributeUsage(AttributeTargets.Class)]
    sealed class ConnectAttribute : Attribute
    {{
        public ConnectAttribute(Type t1, Type t2)
        {{
            LeftName = t1.Name;
            RightName = t2.Name;
        }}

        public string LeftName {{ get; set; }}
        public string RightName {{ get; set; }}
    }}
}} 
";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForPostInitialization((i) => 
            { 
                //i.AddSource("ConnectAttribute.g.cs", attributeSource);
                //i.AddSource("Connection.g.cs", connectionBaseClass);
            });
            context.RegisterForSyntaxNotifications(() => new ConnectionSyntaxReceiver());
        }
        public void Execute(GeneratorExecutionContext context)
        {
            context.AddSource("executed.g.cs", "//yes 2");
            if(!(context.SyntaxContextReceiver is ConnectionSyntaxReceiver receiver))
            {
                return;
            }

            string receiver_info_source = "";

            foreach(ClassDeclarationSyntax clsDecl in receiver.ClassDeclarations)
            {
                receiver_info_source += "//" + clsDecl.Identifier.ToFullString() + "\n";
            }
            receiver_info_source += "//Symbols:\n";
            foreach(ISymbol symbol in receiver.Symbols)
            {
                receiver_info_source += "//" + symbol.ToDisplayString() + ", attributes: ";
                foreach(var ab in symbol.GetAttributes())
                {
                    receiver_info_source += ab.AttributeClass.ToDisplayString() + "(";
                    //receiver_info_source += ab.ToString() + ":";
                    foreach(var arg in ab.ConstructorArguments)
                    {
                        receiver_info_source += arg.Value.ToString() + ",";
                    }
                    receiver_info_source += "), ";
                }
                receiver_info_source += "\n";
            }

            receiver_info_source += "//Connection infos\n";
            foreach(var connInfo in receiver.ConnectionInfos)
            {
                receiver_info_source += $"//{connInfo.Namespace}, {connInfo.ClassName}, {connInfo.LeftType}, {connInfo.RightType}\n";
            }

            context.AddSource("receiver_info.g.cs", $"{receiver_info_source}");

            foreach(var info in receiver.ConnectionInfos)
            { 
                if(info.ContainedTypeWarning)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                    "MG0001",
                    "Contained type warning",
                    "Type {0} is contained in another type and will not be extended.",
                    "yeet",
                    DiagnosticSeverity.Warning,
                    true), info.ClassSymbol.Locations.FirstOrDefault(), info.ClassSymbol.Name));

                    continue;
                }
                string source = $@"// <auto-generated/>
using System;

namespace {info.Namespace}
{{
    public partial class {info.ClassPath} : Connect.Connection<{info.LeftType}, {info.RightType}>
    {{
        public {info.ClassPath} () : base () {{ }}
        public {info.ClassPath} ({info.LeftType} left, {info.RightType} right) : base(left, right) {{ }}
    }}
}}
";
                context.AddSource($"{info.ClassName}.g.cs", source);
            }

        }

        class ConnectionSyntaxReceiver : ISyntaxContextReceiver
        {
            public List<ClassDeclarationSyntax> ClassDeclarations { get; private set; } = new List<ClassDeclarationSyntax>();
            public List<ISymbol> Symbols { get; private set; } = new List<ISymbol> ();
            internal List<ConnectionInfo> ConnectionInfos { get; private set; } = new List<ConnectionInfo> ();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                if (context.Node is ClassDeclarationSyntax classDeclaration)
                {
                    var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as ITypeSymbol;
                    var connectionAttributes = classSymbol.GetAttributes().Where(ab=>ab.AttributeClass.ToDisplayString() == "Connect.ConnectAttribute");
                    if (connectionAttributes.Any())
                    {
                        ClassDeclarations.Add(classDeclaration);
                        Symbols.Add(classSymbol);
                        var ab = connectionAttributes.First();
                        var info = new ConnectionInfo();
                        info.ClassSymbol = classSymbol;
                        if(!(classSymbol.ContainingType is null))
                        {
                            info.ContainedTypeWarning = true;
                        }
                        info.Namespace = classSymbol.ContainingNamespace.ToDisplayString();
                        info.ClassName = classDeclaration.Identifier.ToString();
                        info.ClassPath = classSymbol.ToDisplayString().Substring(info.Namespace.Length+1);
                        info.LeftType = ab.ConstructorArguments[0].Value.ToString();
                        info.RightType = ab.ConstructorArguments[1].Value.ToString();
                        ConnectionInfos.Add(info);
                    }
                }
            }
            internal class ConnectionInfo
            {
                public string Namespace;
                public string ClassName;
                public string ClassPath;
                public string LeftType;
                public string RightType;
                public bool ContainedTypeWarning = false;
                public ISymbol ClassSymbol;
            }
        }
    }
}
